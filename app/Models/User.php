<?php

namespace App\Models;

use Attribute;
use Carbon\Carbon;
use Filament\Models\Contracts\FilamentUser;
use Filament\Panel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades\Hash;
use Laravel\Sanctum\HasApiTokens;
use Spatie\Activitylog\LogOptions;
use Spatie\Activitylog\Traits\LogsActivity;
use Spatie\Permission\Models\Role;
use Spatie\Permission\Traits\HasRoles;
use Tymon\JWTAuth\Contracts\JWTSubject;

class User extends Authenticatable implements FilamentUser, JWTSubject
{
    use HasApiTokens;
    use HasFactory;
    use HasRoles;
    use LogsActivity;
    use Notifiable;

    /*** @return void
     */
    protected static function booted()
    {
        // Definir kyc_required baseado na configuração global antes de criar o usuário
        static::creating(function (User $user) {
            // Se kyc_required não foi definido explicitamente, usar configuração global
            if (! isset($user->attributes['kyc_required'])) {
                $setting = Setting::first();
                $user->kyc_required = $setting ? $setting->kyc_required : true;
            }
        });

        parent::created(function (User $user) {
            $user->createWallet($user);
        }); // TODO: Change the autogenerated stub

        parent::deleted(function (User $user) {
            $user->deleteAll($user);
        }); // TODO: Change the autogenerated stub
    }

    /*** @return void
     */
    public function deleteAll($user)
    {
        $wallet = Wallet::find($user->id);
        if (! empty($wallet)) {
            $wallet->delete();
        }

        $affiliateHistory = AffiliateHistory::where('user_id', $user->id)->get();
        foreach ($affiliateHistory as $affh) {
            $affh->delete();
        }

        $affiliateWithdraw = AffiliateWithdraw::where('user_id', $user->id)->get();
        foreach ($affiliateWithdraw as $affw) {
            $affw->delete();
        }

        $deposits = Deposit::where('user_id', $user->id)->get();
        foreach ($deposits as $dep) {
            $dep->delete();
        }

        $likes = Like::where('user_id', $user->id)->get();
        foreach ($likes as $lk) {
            $lk->delete();
        }

        $transactions = Transaction::where('user_id', $user->id)->get();
        foreach ($transactions as $trans) {
            $trans->delete();
        }

        $withdrawals = Withdrawal::where('user_id', $user->id)->get();
        foreach ($withdrawals as $wts) {
            $wts->delete();
        }

        // Limpar tabelas adicionais
        GameFavorite::where('user_id', $user->id)->delete();
        GameLike::where('user_id', $user->id)->delete();
        GameReview::where('user_id', $user->id)->delete();
        MissionUser::where('user_id', $user->id)->delete();
        Order::where('user_id', $user->id)->delete();
        UserAccount::where('user_id', $user->id)->delete();
        UserDeposit::where('user_id', $user->id)->delete();
        UserDocument::where('user_id', $user->id)->delete();
        MinesGame::where('user_id', $user->id)->delete();
        PopupFreespinRedemption::where('user_id', $user->id)->delete();
        InfluencerBonusRedemption::where('user_id', $user->id)->delete();
        SubAffiliate::where('user_id', $user->id)->delete();
        SuitPayPayment::where('user_id', $user->id)->delete();
        GGRGames::where('user_id', $user->id)->delete();
        GGRGamesFiver::where('user_id', $user->id)->delete();

        // Limpar registros onde o usuário é o afiliado (inviter)
        User::where('inviter', $user->id)->update(['inviter' => null]);

        // Limpar likes recebidos
        Like::where('liked_user_id', $user->id)->delete();
    }

    /*** @return void
     */
    public function createWallet($user)
    {
        $setting = \Helper::getSetting();

        Wallet::create([
            'user_id' => $user->id,
            'currency' => $setting->currency_code,
            'symbol' => $setting->prefix,
            'active' => 1,
        ]);
    }

    /*** The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'role_id',
        'avatar',
        'name',
        'last_name',
        'email',
        'mollie_customer_id',
        'password',
        'phone',
        'cpf',
        'logged_in',
        'banned',
        'ban_reason',
        'inviter',
        'inviter_code',
        'affiliate_revenue_share',
        'affiliate_revenue_share_fake',
        'revshare_visible',
        'affiliate_cpa',
        'affiliate_baseline',
        'is_demo_agent',
        'is_admin',
        'language',
        'role_id',
        'skill_games_min_amount',
        'cpa_enabled',
        'cpa_percentage',
        'affiliate_register_percentage',
        'daily_withdrawal_limit',
        'daily_withdrawal_count_limit',
        'withdrawal_count_today',
        'withdrawal_amount_today',
        'withdrawal_count_reset_at',
        'block_live_games',
        'block_skill_games',
        'block_deposits',
        'skill_games_max_amount',
        'skill_games_difficulty',
        'kyc_required',
        'mines_win_chance',
    ];

    /*** The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /*** The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'password' => 'hashed',
        'daily_withdrawal_limit' => 'decimal:2',
        'withdrawal_amount_today' => 'decimal:2',
        'withdrawal_count_reset_at' => 'datetime',
        'block_live_games' => 'boolean',
        'block_skill_games' => 'boolean',
        'block_deposits' => 'boolean',
        'kyc_required' => 'boolean',
    ];

    protected $appends = ['dateHumanReadable', 'totalLikes', 'createdAtDate'];

    /*** Favorites
     * @return HasMany
     */
    public function favorites(): HasMany
    {
        return $this->hasMany(GameFavorite::class);
    }

    /*** Favorites
     * @return HasMany
     */
    public function likes(): HasMany
    {
        return $this->hasMany(Like::class);
    }

    /*** Interact with the user's first name.
     */
    protected function password(): Attribute
    {
        return Attribute::make(
            set: fn (string $value) => Hash::make($value),
        );
    }

    /*** @return BelongsTo
     */
    public function affiliate(): BelongsTo
    {
        return $this->belongsTo(User::class, 'inviter', 'id');
    }

    /*** @return HasOne
     */
    public function wallet(): HasOne
    {
        return $this->hasOne(Wallet::class)->where('active', 1);
    }

    public function roles(): BelongsToMany
    {
        return $this->belongsToMany(Role::class, 'model_has_roles', 'model_id', 'role_id');
    }

    public function userDocument(): HasOne
    {
        return $this->hasOne(UserDocument::class);
    }

    public function userAccount(): HasOne
    {
        return $this->hasOne(UserAccount::class);
    }

    /*** @param Panel $panel
     * @return bool
     */
    public function canAccessPanel(Panel $panel): bool
    {
        return $this->hasRole(['admin', 'afiliado']);
    }

    /*** @return int
     */
    public function getTotalLikesAttribute()
    {
        return $this->likes()->count();
    }

    /*** Retorna apenas a data para compatibilidade com APIs
     * @return string
     */
    public function getCreatedAtDateAttribute()
    {
        return $this->created_at ? $this->created_at->format('Y-m-d') : null;
    }

    /*** Retorna a data e hora completa para uso interno
     * @return \Carbon\Carbon|null
     */
    public function getCreatedAtFullAttribute()
    {
        return $this->created_at;
    }

    /*** @return mixed
     */
    public function getDateHumanReadableAttribute()
    {
        return Carbon::parse($this->created_at)->diffForHumans();
    }

    /*** Get the identifier that will be stored in the subject claim of the JWT.
     *
     * @return mixed
     */
    public function getJWTIdentifier()
    {
        return $this->getKey();
    }

    /*** Return a key value array, containing any custom claims to be added to the JWT.
     *
     * @return array
     */
    public function getJWTCustomClaims()
    {
        return [];
    }

    /**
     * Verifica e atualiza os limites de saque diários
     */
    public function checkAndUpdateWithdrawalLimits()
    {
        // Configurar timezone para Lisboa (Europe/Lisbon)
        $lisbonTime = now()->setTimezone('Europe/Lisbon');

        // Se não houver data de reset ou se a data atual em Lisboa for um dia diferente da data de reset
        if ($this->withdrawal_count_reset_at === null) {
            // Primeira vez, inicializa com os valores zerados
            $this->withdrawal_count_today = 0;
            $this->withdrawal_amount_today = 0;
            $this->withdrawal_count_reset_at = now();
            $this->save();

            return;
        }

        // Obtém a data do último reset em Lisboa
        $lastResetLisbon = $this->withdrawal_count_reset_at->setTimezone('Europe/Lisbon');

        // Se o dia atual for diferente do dia do último reset, reseta os contadores
        if ($lisbonTime->format('Y-m-d') !== $lastResetLisbon->format('Y-m-d')) {
            $this->withdrawal_count_today = 0;
            $this->withdrawal_amount_today = 0;
            $this->withdrawal_count_reset_at = now();
            $this->save();
        }
    }

    /**
     * Verifica se o usuário pode realizar um saque
     *
     * @param  float  $amount  Valor do saque
     * @return array ['can_withdraw' => bool, 'message' => string]
     */
    public function canWithdraw($amount)
    {
        $this->checkAndUpdateWithdrawalLimits();

        // Verifica limite de quantidade de saques
        if ($this->daily_withdrawal_count_limit !== null &&
            $this->withdrawal_count_today >= $this->daily_withdrawal_count_limit) {
            return [
                'can_withdraw' => false,
                'message' => 'Você atingiu o limite de saques diários',
            ];
        }

        // Verifica limite de valor
        if ($this->daily_withdrawal_limit !== null) {
            $remaining = $this->daily_withdrawal_limit - $this->withdrawal_amount_today;
            if ($amount > $remaining) {
                return [
                    'can_withdraw' => false,
                    'message' => "Valor excede o limite diário restante de {$remaining}",
                ];
            }
        }

        return ['can_withdraw' => true, 'message' => ''];
    }

    /**
     * Registra um novo saque realizado
     *
     * @param  float  $amount  Valor do saque
     */
    public function registerWithdrawal($amount)
    {
        $this->checkAndUpdateWithdrawalLimits(); // Garantir que os limites estejam atualizados antes de registrar
        $this->increment('withdrawal_count_today');
        $this->increment('withdrawal_amount_today', $amount);
        $this->save();
    }

    /**
     * Accessor para garantir que withdrawal_count_today sempre retorne o valor atualizado
     *
     * @return int
     */
    public function getWithdrawalCountTodayAttribute($value)
    {
        $this->checkAndUpdateWithdrawalLimits();

        return $this->attributes['withdrawal_count_today'];
    }

    /**
     * Accessor para garantir que withdrawal_amount_today sempre retorne o valor atualizado
     *
     * @return float
     */
    public function getWithdrawalAmountTodayAttribute($value)
    {
        $this->checkAndUpdateWithdrawalLimits();

        return $this->attributes['withdrawal_amount_today'];
    }

    /**
     * Configuração para o registro de atividades
     */
    public function getActivitylogOptions(): LogOptions
    {
        return LogOptions::defaults()
            ->logOnly(['name', 'email', 'logged_in', 'banned'])
            ->logOnlyDirty()
            ->dontSubmitEmptyLogs();
    }

    /**
     * Método para lidar com a invalidação de tokens quando o usuário é banido
     * Como estamos usando JWT e não Sanctum, este método é apenas um stub
     * que retorna uma coleção vazia para evitar erros
     */
    public function tokens()
    {
        // Retorna uma coleção vazia que suporta o método delete()
        return new \Illuminate\Database\Eloquent\Collection;
    }
}
